"""
This type stub file was generated by pyright.
"""

from types import ModuleType
from io import TextIOWrapper

'''Utility functions and classes to support automated testing'''
MULTITHREADED = ...
PACKAGE_THREAD_COUNT = ...
MODULE_THREAD_COUNT = ...
INPROCESS_TEST_PREFIX = ...
SUBPROCESS_TEST_PREFIX = ...
BATCH_TEST_PREFIX = ...
COMMAND_PREFIX_ADDITIONS = ...
DISABLED_TESTS_SYMBOL = ...
INPROCESS_RESULT_PREFIX = ...
SUBPROCESS_CODE_PREFIX = ...
TEST_OUTPUT_PREFIX = ...
TEST_ERROR_PREFIX = ...
TESTING_TOKEN = ...
redirect = ...
redirect_lock = ...
module_lock = ...
COLOR = ...
class TestResults:
    def __init__(self, packageName) -> None:
        ...
    
    def add_success(self): # -> None:
        ...
    
    def add_failure(self): # -> None:
        ...
    
    def print(self): # -> None:
        ...
    


def summarize_results(name, *results): # -> TestResults:
    '''Produce a summary TestResults object from the given results

    :param name: a descriptive name for the summary results
    :param results: TestResults objects to be summarized
    :return: a summary TestResults object
    '''
    ...

def cull_debug_lines(lines, std): # -> Literal['']:
    '''Remove lines formatted like debug output, and print them to a stream

    Allows tests to run with -g without false failures due to extraneous output.
    :param lines: lines of output
    :param std: output stream to print the culled debug text
    :return: the text without debug content concatenated into a string
    '''
    ...

def cull_debug_text(text, std): # -> Literal['']:
    '''Remove text formatted like debug output, and print it to a stream

    Allow tests to run with -g without false failures due to extraneous output.
    :param lines: a string of text
    :param std: output stream to print the culled debug text
    :return: the text without debug content
    '''
    ...

class Redirect(TextIOWrapper):
    """
    Manages the redirection and restoration of stdout and stderr
    """
    def __init__(self) -> None:
        ...
    
    def get_output(self): # -> tuple[str, str]:
        ...
    
    def restore(self): # -> None:
        ...
    


def init_testing(): # -> None:
    ...

def print_expected_actual_mismatch(testId, expected, actual, expectedTitle=..., actualTitle=..., command=...): # -> None:
    ...

def check_code(mod, testName, expectedVarname, code, command=...): # -> bool:
    ...

def check_result(mod, testName, expectedVarname, testResult, command=...): # -> bool:
    ...

def get_test_identifier(mod, testName): # -> LiteralString:
    ...

def check_output(mod, testName, expectedVarname, output, streamName, command=...): # -> bool:
    ...

def run_test(mod, testName): # -> bool:
    '''Run a test that executes code to validate behavior

    Triggered by creating a function "test_*" in the test module.
    Intended for unit testing.
    :param mod: the test module
    :param testName: name of the test in the module (including "test_" prefix)
    :return: boolean indicating whether the test passed
    '''
    ...

def check_process_result(mod, testName, testPrefix, processResult, command=...): # -> bool:
    '''Validate results of a test that ran as a subprocess

    :param mod: the test module
    :param testName: name of the test in the module (including prefix)
    :param testPrefix: string prefix (e.g. "run_") of the testName
    :param processResult: result of the call to `subprocess.run`
    :return: boolean indicating whether the test passed
    '''
    ...

def run_subprocess(mod, testName, commandPrefix=...): # -> bool:
    '''Run a test that specifies arguments to run a subprocess

    Triggered by setting a variable "run_*" in the test module to a list of
    arguments. Intended to test user interaction and output.
    :param mod: the test module
    :param testName: name of the test in the module (including "run_" prefix)
    :return: boolean indicating whether the test passed
    '''
    ...

def run_batch(mod, testName, commandPrefix=...): # -> bool:
    '''Run a batch test that reads stdin to perform a series of operations

    Triggered by setting a variable "batch_*" in the test module to a list of
    arguments, the last of which is a string representing the newline-separated
    commands to be sent to stdin. Intended to test batch operations and output.
    :param mod: the test module
    :param testName: name of the test in the module (including "batch_" prefix)
    :return: boolean indicating whether the test passed
    '''
    ...

def print_exception(exception): # -> None:
    ...

def print_divider(): # -> None:
    ...

def print_error(msg): # -> None:
    ...

def print_result(packageName, modName, testName, result): # -> None:
    ...

def print_pass(packageName, modName, testName): # -> None:
    ...

def print_fail(packageName, modName, testName): # -> None:
    ...

def copy_store_to_mirror(sourceOption, targetOption): # -> None:
    ...

def initialize_dynamic_test_stores(testPackages): # -> None:
    '''Copy source files/databases to associated mirrors for testing'''
    ...

def clean_dynamic_test_stores(dynamicTestStores): # -> None:
    '''Remove dynamically-created test files'''
    ...

def wait_condition(): # -> bool:
    ...

def redirect_output(): # -> None:
    ...

def restore_output(): # -> tuple[str, str]:
    ...

def run_module(mod: ModuleType, packageName, results, commandPrefix=...): # -> None:
    '''
    Invoke all tests in a module and print individual results.

    This function is the unit of parallelism. Anything called from here should
    lock or otherwise take care before accessing shared data or resources.

    Individual tests within a module run serially to allow for intramodule data
    dependency.
    :param mod: Module, object representing the test module
    :param packageName: string, name of the package of which this module is part
    :param results: TestResults, an object to collect detailed test outcomes
    '''
    ...

def run_modules(packageName, moduleMap, commandPrefix=...): # -> TestResults:
    '''Run a set of test modules and print cumulative results.

    This function is the entry point to be called from __init__.py in the
    package directory defining a suite of test modules. Typical boilerplate is:

        from rjtools.util.testing import run_modules

        def run():
            from . import mytestmodule
            from . import anothermodule

            return run_modules("package name", locals())

    which calls this function to run the `mytestmodule` and `anothermodule` test
    modules. The grouping of modules is called "suitename" in reporting.
    :param packageName: name of the test package, for summary display purposes
    :param moduleMap: map of module name to the module object
    :param commandPrefix: list of command-line arguments to prepend
    :return: a TestResults object summarizing the results from the modules
    '''
    ...

def run_package(package, results): # -> None:
    ...

def run_packages(suiteName, packageMap): # -> TestResults:
    '''Run a collection of test packages typically corresponding to an app.

    The packages correspond to Python packages, and are comprised of test
    modules corresponding to Python modules.

    This function is the entrypoint for a test suite to invoke test packages
        it contains, via the package's __init__.py file. Typical boilerplate is:

        from rjtools.util.testing import run_packages

        def run():
            from . import unit
            from . import user
            from . import batch

            return run_packages("suite name", locals())

    :param suiteName: descriptive name of test suite containing these packages
    :param packageMap: map containing package objects (of type
        ModuleType) representing test packages; supports list for manual
        listing, and map to support passing `locals()`
    :return: TestResults object summarizing the test packages that were run
    '''
    ...

def run_suite():
    '''Encapsulates the boilerplate needed to run a test suite from __main__.py

    For any test suite/package, the following code is all that's needed in
    __main__.py:

        from rjtools.util.testing import run_suite
        from . import run
        run_suite()

    Note that the test suite must import the `run` method from __init__.py.
    The process is terminated after completion.
    '''
    ...

